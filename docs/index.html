<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Coordinate Timeline Viewer</title>
    <style>
      :root {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #1b1b1b;
        background-color: #f7f7f7;
      }
      body {
        margin: 0;
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-height: 100vh;
        box-sizing: border-box;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 1.6rem;
      }
      h2 {
        margin: 12px 0;
        font-size: 1.1rem;
      }
      p {
        margin: 0;
        color: #555;
      }
      label {
        font-weight: 600;
        display: inline-flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
      }
      .panel {
        background: white;
        border-radius: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        padding: 20px 24px;
      }
      .loader-area {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-top: 16px;
      }
      .loader-area input[type="file"] {
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 6px;
        background: #fafafa;
      }
      #error {
        color: #c0392b;
        font-weight: 600;
        margin-top: 12px;
      }
      canvas {
        width: 100%;
        height: 480px;
        border: 1px solid #ddd;
        border-radius: 6px;
        background: #fff;
        cursor: grab;
      }
      .layout {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }
      .left-col {
        flex: 2 1 520px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .right-col {
        flex: 1 1 260px;
        min-width: 240px;
        background: #fafafa;
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 12px 16px;
        max-height: 560px;
        overflow-y: auto;
      }
      .controls {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .controls input[type="range"] {
        flex: 1;
      }
      button {
        padding: 6px 12px;
        font-size: 0.95rem;
        border-radius: 6px;
        cursor: pointer;
        border: 1px solid #bbb;
        background: #fafafa;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #details {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
      }
      .detail-box {
        background: #f1f1f1;
        border-radius: 6px;
        padding: 10px;
        font-size: 0.92rem;
        line-height: 1.4;
      }
      .track-row {
        display: grid;
        grid-template-columns: auto auto auto 16px 1fr;
        align-items: center;
        gap: 10px;
        padding: 8px 0;
        border-bottom: 1px solid #e5e5e5;
      }
      .track-row button {
        padding: 4px 8px;
        font-size: 0.85rem;
      }
      .track-row:last-child {
        border-bottom: none;
      }
      .track-row input[type="checkbox"],
      .track-row input[type="radio"] {
        width: 16px;
        height: 16px;
      }
      .track-swatch {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid rgba(0, 0, 0, 0.2);
      }
      .track-name {
        font-weight: 600;
        font-size: 0.95rem;
      }
      .track-meta {
        grid-column: 2 / span 3;
        font-size: 0.8rem;
        color: #666;
      }
      .note {
        font-size: 0.85rem;
        color: #777;
        margin-top: 8px;
      }
      .zoom-toolbar {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }
      .zoom-buttons {
        display: inline-flex;
        gap: 8px;
      }
      #zoomDisplay {
        font-size: 0.9rem;
        color: #333;
      }
      .axis-toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 4px;
        flex-wrap: wrap;
        font-size: 0.9rem;
        color: #333;
      }
      .axis-toolbar select {
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #bbb;
        background: #fff;
      }
      .reach-toolbar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 12px;
        margin-top: 12px;
        font-size: 0.9rem;
        color: #333;
      }
      .reach-toolbar label {
        display: inline-flex;
        flex-direction: column;
        gap: 4px;
      }
      .reach-toolbar label.reach-toggle {
        flex-direction: row;
        align-items: center;
        gap: 6px;
        font-weight: 600;
      }
      .reach-toolbar input[type="number"] {
        width: 90px;
        padding: 4px 6px;
        border-radius: 4px;
        border: 1px solid #bbb;
        background: #fff;
        font-size: 0.9rem;
      }
      .reach-toolbar input[type="number"]:disabled {
        background: #f3f3f3;
        color: #888;
      }
      .reach-count {
        font-weight: 600;
        color: #2980b9;
        margin-left: auto;
      }
      .export-toolbar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 12px;
        margin-top: 12px;
        font-size: 0.9rem;
        color: #333;
      }
      .export-toolbar .export-group {
        display: inline-flex;
        align-items: center;
        gap: 10px;
      }
      .export-toolbar label {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-weight: 600;
      }
      .export-toolbar .export-group button {
        padding: 6px 10px;
        border-radius: 4px;
        border: 1px solid #bbb;
        background: #fff;
        cursor: pointer;
      }
      .export-toolbar .export-group button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .export-toolbar .export-group input[type="checkbox"] {
        width: 16px;
        height: 16px;
      }
      .export-toolbar .export-group input[type="number"] {
        width: 72px;
        padding: 4px 6px;
        border: 1px solid #bbb;
        border-radius: 4px;
        font-size: 0.9rem;
        background: #fff;
      }
      .export-toolbar .export-group input[type="number"]:disabled {
        background: #f3f3f3;
        color: #888;
      }
      canvas.dragging {
        cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <div class="panel">
      <h1>Coordinate Timeline Viewer</h1>
      <p>
        Select one or more JSON files containing timestamped coordinates (x, y,
        z). The first point in each file is treated as the origin at (0, 0, 0).
      </p>
      <div class="loader-area">
        <label>
          Load JSON files
          <input
            type="file"
            id="fileInput"
            accept="application/json"
            multiple
          />
        </label>
        <label>
          Load JSON folder
          <input
            type="file"
            id="folderInput"
            accept="application/json"
            webkitdirectory
            multiple
          />
        </label>
      </div>
      <p class="note">
        The folder picker works best in Chromium-based browsers (Chrome, Edge,
        Arc). Safari and Firefox may not fully support automatic folder loading.
      </p>
      <div id="error"></div>
    </div>

    <div class="panel">
      <h2>Additional Reports</h2>
      <p>
        Need a table of escape timings? Open&nbsp;
        <a href="./escape-report/index.html">Escape Time Report</a>
        to load CSV/JSON logs and list when tracks left a radius.
      </p>
    </div>

    <div id="viewer" class="panel" style="display: none">
      <div class="layout">
        <div class="left-col">
          <canvas id="plot" width="960" height="480"></canvas>
          <div class="controls">
            <label for="position">Frame</label>
            <input
              type="range"
              id="position"
              min="0"
              max="0"
              value="0"
              step="1"
              disabled
            />
            <button id="playPause" disabled>Play</button>
          </div>
          <div class="zoom-toolbar">
            <span id="zoomDisplay">Zoom: 100%</span>
            <div class="zoom-buttons">
              <button type="button" id="zoomIn">Zoom In</button>
              <button type="button" id="zoomOut">Zoom Out</button>
              <button type="button" id="zoomReset">Fit View</button>
            </div>
          </div>
          <div class="axis-toolbar">
            <label for="axisMode">Projection</label>
            <select id="axisMode">
              <option value="xy">X vs Y</option>
              <option value="xz">X vs Z</option>
            </select>
          </div>
          <div class="reach-toolbar">
            <label class="reach-toggle">
              <input type="checkbox" id="reachToggle" />
              Escape distance counter
            </label>
            <label>
              Center X (dx)
              <input type="number" id="reachTargetX" step="0.5" value="0" />
            </label>
            <label>
              Center Y (dy)
              <input type="number" id="reachTargetY" step="0.5" value="0" />
            </label>
            <label>
              Center Z (dz)
              <input type="number" id="reachTargetZ" step="0.5" value="0" />
            </label>
            <label>
              Escape radius (blocks)
              <input
                type="number"
                id="reachRadius"
                step="0.5"
                min="0"
                value="5"
              />
            </label>
            <span id="reachSummary" class="reach-count"></span>
          </div>
          <div class="export-toolbar">
            <div class="export-group">
              <label>
                <input type="checkbox" id="showPathsToggle" checked />
                Path
              </label>
              <label>
                <input type="checkbox" id="showCircleToggle" checked />
                Escape circle
              </label>
            </div>
            <div class="export-group">
              <label>
                <input type="checkbox" id="cropToggle" />
                Crop square
              </label>
              <label>
                Size (blocks)
                <input type="number" id="cropSize" value="50" min="1" step="1" />
              </label>
              <label>
                Center
                <select id="cropCenterMode">
                  <option value="origin">Track origin</option>
                  <option value="escape">Escape target</option>
                </select>
              </label>
            </div>
            <div class="export-group">
              <button type="button" id="centerView">Center view</button>
              <button type="button" id="exportPng">Export PNG</button>
              <button type="button" id="exportSvg">Export SVG</button>
            </div>
          </div>
          <div id="details">
            <div class="detail-box" id="trackBox"></div>
            <div class="detail-box" id="timestampBox"></div>
            <div class="detail-box" id="absoluteBox"></div>
            <div class="detail-box" id="relativeBox"></div>
          </div>
        </div>
        <div class="right-col">
          <h2>Tracks</h2>
          <div id="trackList"></div>
        </div>
      </div>
    </div>

    <script>
      const fileInput = document.getElementById("fileInput");
      const folderInput = document.getElementById("folderInput");
      const errorBox = document.getElementById("error");
      const viewer = document.getElementById("viewer");
      const canvas = document.getElementById("plot");
      const ctx = canvas.getContext("2d");
      const slider = document.getElementById("position");
      const playPause = document.getElementById("playPause");
      const trackBox = document.getElementById("trackBox");
      const timestampBox = document.getElementById("timestampBox");
      const absoluteBox = document.getElementById("absoluteBox");
      const relativeBox = document.getElementById("relativeBox");
      const zoomInButton = document.getElementById("zoomIn");
      const zoomOutButton = document.getElementById("zoomOut");
      const zoomResetButton = document.getElementById("zoomReset");
      const zoomDisplay = document.getElementById("zoomDisplay");
      const axisModeSelect = document.getElementById("axisMode");
      const reachToggle = document.getElementById("reachToggle");
      const reachTargetXInput = document.getElementById("reachTargetX");
      const reachTargetYInput = document.getElementById("reachTargetY");
      const reachTargetZInput = document.getElementById("reachTargetZ");
      const reachRadiusInput = document.getElementById("reachRadius");
      const reachSummary = document.getElementById("reachSummary");
      const showPathsToggle = document.getElementById("showPathsToggle");
      const showCircleToggle = document.getElementById("showCircleToggle");
      const cropToggle = document.getElementById("cropToggle");
      const cropSizeInput = document.getElementById("cropSize");
      const cropCenterModeSelect = document.getElementById("cropCenterMode");
      const centerViewButton = document.getElementById("centerView");
      const exportPngButton = document.getElementById("exportPng");
      const exportSvgButton = document.getElementById("exportSvg");

      const colorCache = new Map();
      const goldenAngle = 137.508;
      const saturationCycle = [70, 62, 78, 68, 74];
      const lightnessCycle = [52, 46, 58, 48, 55];

      function getTrackColor(index, key) {
        if (colorCache.has(key)) {
          return colorCache.get(key);
        }
        const hue = (index * goldenAngle) % 360;
        const saturation = saturationCycle[index % saturationCycle.length];
        const lightness = lightnessCycle[index % lightnessCycle.length];
        const color = `hsl(${hue.toFixed(1)}, ${saturation}%, ${lightness}%)`;
        colorCache.set(key, color);
        return color;
      }

      let tracks = [];
      let selectedTrackIds = new Set();
      let activeTrackId = null;
      let hoveredTrackId = null;
      let soloMode = { enabled: false, trackId: null, prevSelection: null };
      let globalTimeline = [];
      let animationId = null;
      let isPlaying = false;
      let trackCounter = 0;
      let axisMode = "xy";
      // --- Stuck detection parameters ---
      // A track is considered "stuck" if the standard deviation over the most recent
      // 750 projected points (in the current projection) is below 2.
      const STUCK_WINDOW = 750;
      const STUCK_STD_THRESHOLD = 2;
      const viewState = { zoom: 1, offsetX: 0, offsetY: 0 };
      const minZoom = 0.25;
      const maxZoom = 12;
      let lastRenderContext = null;
      let isPanning = false;
      let panPointerId = null;
      let panStart = { x: 0, y: 0, offsetX: 0, offsetY: 0 };
      const reachOptions = {
        enabled: false,
        target: { x: 0, y: 0, z: 0 },
        radius: 5,
      };
      const displayOptions = {
        showPaths: true,
        showEscapeCircle: true,
        crop: { enabled: false, size: 50, centerMode: "origin" },
      };

      fileInput.addEventListener("change", (event) => {
        handleFileSelection(event.target.files);
      });

      folderInput.addEventListener("change", (event) => {
        handleFileSelection(event.target.files);
      });

      slider.addEventListener("input", (event) => {
        stopPlayback(false);
        drawFrame(Number(event.target.value));
      });

      playPause.addEventListener("click", () => {
        if (isPlaying) {
          stopPlayback(false);
        } else {
          startPlayback();
        }
      });

      zoomInButton.addEventListener("click", () => {
        applyZoom(1.2, canvas.width / 2, canvas.height / 2);
      });

      zoomOutButton.addEventListener("click", () => {
        applyZoom(1 / 1.2, canvas.width / 2, canvas.height / 2);
      });

      zoomResetButton.addEventListener("click", () => {
        resetView();
      });

      axisModeSelect.value = axisMode;
      axisModeSelect.addEventListener("change", () => {
        axisMode = axisModeSelect.value;
        resetView(true);
        drawFrame(Number(slider.value));
      });

      reachToggle.addEventListener("change", () => {
        reachOptions.enabled = reachToggle.checked;
        syncReachInputState();
        evaluateReach();
        refreshTrackList();
        updateReachSummary();
        drawFrame(Number(slider.value));
      });

      const reachInputElements = [
        reachTargetXInput,
        reachTargetYInput,
        reachTargetZInput,
        reachRadiusInput,
      ];

      reachInputElements.forEach((input) => {
        input.addEventListener("input", () => {
          handleReachInputChange();
        });
      });

      showPathsToggle.addEventListener("change", () => {
        displayOptions.showPaths = showPathsToggle.checked;
        drawFrame(Number(slider.value));
      });

      showCircleToggle.addEventListener("change", () => {
        displayOptions.showEscapeCircle = showCircleToggle.checked;
        drawFrame(Number(slider.value));
      });

      cropToggle.addEventListener("change", () => {
        displayOptions.crop.enabled = cropToggle.checked;
        syncCropInputs();
        drawFrame(Number(slider.value));
      });

      cropSizeInput.addEventListener("input", () => {
        const nextSize = parseCropSize(cropSizeInput.value);
        displayOptions.crop.size = nextSize;
        if (displayOptions.crop.enabled) {
          drawFrame(Number(slider.value));
        }
      });

      cropCenterModeSelect.addEventListener("change", () => {
        displayOptions.crop.centerMode = cropCenterModeSelect.value;
        if (displayOptions.crop.enabled) {
          drawFrame(Number(slider.value));
        }
      });

      exportPngButton.addEventListener("click", () => {
        exportPNG();
      });

      exportSvgButton.addEventListener("click", () => {
        exportSVG();
      });

      centerViewButton.addEventListener("click", () => {
        centerView();
      });

      syncReachInputState();
      displayOptions.showPaths = showPathsToggle.checked;
      displayOptions.showEscapeCircle = showCircleToggle.checked;
      displayOptions.crop.enabled = cropToggle.checked;
      displayOptions.crop.size = parseCropSize(cropSizeInput.value);
      displayOptions.crop.centerMode = cropCenterModeSelect.value;
      updateReachSummary();
      syncExportControls(false);
      syncCropInputs();
      handleReachInputChange();

      canvas.addEventListener("wheel", handleWheel, { passive: false });
      canvas.addEventListener("pointerdown", handlePointerDown);
      canvas.addEventListener("pointermove", handlePointerMove);
      canvas.addEventListener("pointerup", handlePointerUp);
      canvas.addEventListener("pointerleave", handlePointerUp);
      canvas.addEventListener("pointercancel", handlePointerUp);

      function parseReachNumber(value) {
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : 0;
      }

      function parseCropSize(value) {
        const numeric = Math.max(1, Math.round(Number(value)) || 1);
        cropSizeInput.value = numeric;
        return numeric;
      }

      function syncReachInputState() {
        const disabled = !reachOptions.enabled;
        reachInputElements.forEach((input) => {
          input.disabled = disabled;
        });
        showCircleToggle.disabled = disabled;
        if (!reachOptions.enabled) {
          reachSummary.textContent = "";
        }
      }

      function syncCropInputs() {
        const disabled = !displayOptions.crop.enabled;
        cropSizeInput.disabled = disabled;
        cropCenterModeSelect.disabled = disabled;
      }

      function handleReachInputChange() {
        reachOptions.target.x = parseReachNumber(reachTargetXInput.value);
        reachOptions.target.y = parseReachNumber(reachTargetYInput.value);
        reachOptions.target.z = parseReachNumber(reachTargetZInput.value);
        const radius = parseReachNumber(reachRadiusInput.value);
        const clampedRadius = Math.max(0, radius);
        if (clampedRadius !== radius) {
          reachRadiusInput.value = clampedRadius;
        }
        reachOptions.radius = clampedRadius;
        if (reachOptions.enabled) {
          evaluateReach();
          refreshTrackList();
          updateReachSummary();
          drawFrame(Number(slider.value));
        }
      }

      function evaluateReach() {
        if (!reachOptions.enabled) {
          tracks.forEach((track) => {
            track.escapedRadius = false;
          });
          return;
        }
        const radiusSq = reachOptions.radius * reachOptions.radius;
        const EPS = Math.max(1e-6, radiusSq * 1e-4); // slight buffer so small jitters don't count as escape
        tracks.forEach((track) => {
          let escaped = false;
          let sawInside = false;
          const offsets = track.offsets || [];
          for (let i = 0; i < offsets.length; i++) {
            const offset = offsets[i];
            const dx = offset.dx - reachOptions.target.x;
            const dy = offset.dy - reachOptions.target.y;
            const dz = offset.dz - reachOptions.target.z;
            const distSq = dx * dx + dy * dy + dz * dz;
            if (!sawInside && distSq <= radiusSq + EPS) {
              sawInside = true;
              continue;
            }
            if (sawInside && distSq >= radiusSq + EPS) {
              escaped = true;
              break;
            }
          }
          track.escapedRadius = escaped;
        });
      }

      function updateReachSummary() {
        if (!reachOptions.enabled) {
          reachSummary.textContent = "";
          return;
        }
        if (!tracks.length) {
          reachSummary.textContent = "Escaped: 0/0";
          return;
        }
        let visibleReached = 0;
        let visibleTotal = 0;
        let totalReached = 0;
        tracks.forEach((track) => {
          if (track.escapedRadius) {
            totalReached += 1;
          }
          if (selectedTrackIds.has(track.id)) {
            visibleTotal += 1;
            if (track.escapedRadius) {
              visibleReached += 1;
            }
          }
        });
        const totalLabel = `${visibleReached}/${visibleTotal || 0} visible`;
        const allLabel = `${totalReached}/${tracks.length} total`;
        reachSummary.textContent = `Escaped: ${totalLabel} • ${allLabel}`;
      }

      function prepareExportSnapshot() {
        const totalFrames = globalTimeline.length;
        if (!totalFrames) {
          return null;
        }
        const rawIndex = Number(slider.value);
        const clampedIndex = Math.min(
          Math.max(Number.isFinite(rawIndex) ? rawIndex : 0, 0),
          totalFrames - 1
        );
        const targetTimestamp = globalTimeline[clampedIndex];
        const visibleTracks = tracks.filter((track) =>
          selectedTrackIds.has(track.id)
        );
        const active = getActiveTrack();
        if (!visibleTracks.length || !active) {
          return null;
        }
        const trackHighlights = visibleTracks.map((track) => ({
          track,
          highlightIndex: findNearestIndex(track, targetTimestamp, clampedIndex),
        }));
        const margin = 40;
        const width = canvas.width - margin * 2;
        const height = canvas.height - margin * 2;
        let context = null;
        if (
          lastRenderContext &&
          lastRenderContext.axisMode === axisMode &&
          lastRenderContext.bounds
        ) {
          context = {
            bounds: { ...lastRenderContext.bounds },
            margin: lastRenderContext.margin,
            scale: lastRenderContext.scale,
          };
        } else {
          const bounds = computeBounds(visibleTracks);
          let finalBounds = { ...bounds };
          if (displayOptions.crop.enabled) {
            const center = computeCropCenter();
            const halfSize = (displayOptions.crop.size || 1) / 2;
            finalBounds = {
              minPrimary: center.primary - halfSize,
              maxPrimary: center.primary + halfSize,
              minSecondary: center.secondary - halfSize,
              maxSecondary: center.secondary + halfSize,
            };
          }
          const spanPrimary = finalBounds.maxPrimary - finalBounds.minPrimary || 1;
          const spanSecondary =
            finalBounds.maxSecondary - finalBounds.minSecondary || 1;
          const scale = Math.min(width / spanPrimary, height / spanSecondary);
          context = { bounds: finalBounds, margin, scale };
        }
        return {
          clampedIndex,
          targetTimestamp,
          visibleTracks,
          trackHighlights,
          context,
        };
      }

      function exportPNG() {
        if (!tracks.length) {
          errorBox.textContent = "No data loaded to export.";
          return;
        }
        const snapshot = prepareExportSnapshot();
        if (!snapshot) {
          errorBox.textContent = "Nothing visible to export.";
          return;
        }
        drawFrame(snapshot.clampedIndex);
        const filename = createExportFilename("png");
        if (canvas.toBlob) {
          canvas.toBlob((blob) => {
            if (!blob) {
              errorBox.textContent = "Failed to create PNG blob.";
              return;
            }
            downloadBlob(blob, filename);
          });
          return;
        }
        const dataUrl = canvas.toDataURL("image/png");
        downloadDataUrl(dataUrl, filename);
      }

      function exportSVG() {
        if (!tracks.length) {
          errorBox.textContent = "No data loaded to export.";
          return;
        }
        const snapshot = prepareExportSnapshot();
        if (!snapshot) {
          errorBox.textContent = "Nothing visible to export.";
          return;
        }
        const svgString = buildSVGString(snapshot);
        const blob = new Blob([svgString], { type: "image/svg+xml" });
        downloadBlob(blob, createExportFilename("svg"));
      }

      function buildSVGString(snapshot) {
        const { context, trackHighlights, visibleTracks, targetTimestamp, clampedIndex } =
          snapshot;
        const width = canvas.width;
        const height = canvas.height;
        const pieces = [];
        pieces.push('<?xml version="1.0" encoding="UTF-8"?>');
        pieces.push(
          `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`
        );
        pieces.push('<rect width="100%" height="100%" fill="#ffffff"/>');

        const zoomLevel = viewState.zoom || 1;
        const scaleFactor = context.scale * zoomLevel || 1;

      const cropRect =
        displayOptions.crop.enabled && displayOptions.crop.size > 0
          ? computeCropRect(context)
          : null;
        let clipId = null;
        if (
          cropRect &&
          Number.isFinite(cropRect.width) &&
          Number.isFinite(cropRect.height) &&
          cropRect.width > 0 &&
          cropRect.height > 0
        ) {
          clipId = `clip-${Math.random().toString(36).slice(2, 10)}`;
          pieces.push(
            `<defs><clipPath id="${clipId}"><rect x="${cropRect.x.toFixed(
              2
            )}" y="${cropRect.y.toFixed(2)}" width="${cropRect.width.toFixed(
              2
            )}" height="${cropRect.height.toFixed(2)}"/></clipPath></defs>`
          );
          pieces.push(`<g clip-path="url(#${clipId})">`);
        }

        // Axes (if crossing zero)
        if (context.bounds.minSecondary <= 0 && context.bounds.maxSecondary >= 0) {
          const start = projectedToCanvas(context.bounds.minPrimary, 0, context);
          const end = projectedToCanvas(context.bounds.maxPrimary, 0, context);
          pieces.push(
            `<line x1="${start.x.toFixed(2)}" y1="${start.y.toFixed(2)}" x2="${end.x.toFixed(2)}" y2="${end.y.toFixed(2)}" stroke="#e0e0e0" stroke-width="1" stroke-dasharray="4 4"/>`
          );
        }
        if (context.bounds.minPrimary <= 0 && context.bounds.maxPrimary >= 0) {
          const start = projectedToCanvas(0, context.bounds.minSecondary, context);
          const end = projectedToCanvas(0, context.bounds.maxSecondary, context);
          pieces.push(
            `<line x1="${start.x.toFixed(2)}" y1="${start.y.toFixed(2)}" x2="${end.x.toFixed(2)}" y2="${end.y.toFixed(2)}" stroke="#e0e0e0" stroke-width="1" stroke-dasharray="4 4"/>`
          );
        }

        if (displayOptions.showPaths) {
          visibleTracks.forEach((track) => {
            const projection = track.projections?.[axisMode];
            if (!projection || !projection.points.length) {
              return;
            }
            const pathD = buildSVGPath(projection.points, context);
            if (!pathD) {
              return;
            }
            const isActive = track.id === activeTrackId;
            const opacity = isActive ? 1 : 0.55;
            const strokeWidth = ((isActive ? 2.5 : 1.8) / scaleFactor).toFixed(2);
            pieces.push(
              `<path d="${pathD}" fill="none" stroke="${track.color}" stroke-width="${strokeWidth}" stroke-linejoin="round" stroke-linecap="round" opacity="${opacity}"/>`
            );
          });
        }

        // Highlight markers
        trackHighlights.forEach(({ track, highlightIndex }) => {
          const projection = track.projections?.[axisMode];
          if (!projection || !projection.points.length) {
            return;
          }
          const safeIndex = Math.min(
            Math.max(highlightIndex, 0),
            projection.points.length - 1
          );
          const highlightPoint = projection.points[safeIndex];
          if (!highlightPoint) {
            return;
          }
          const { x, y } = projectedToCanvas(
            highlightPoint.primary,
            highlightPoint.secondary,
            context
          );
          const ended = hasTrackEndedAt(track, targetTimestamp, clampedIndex);
          const stuckNow = !ended && isStuckAt(track, safeIndex);
          const isActive = track.id === activeTrackId;
          const fillColor = ended
            ? "#f1c40f"
            : stuckNow
            ? "#8e44ad"
            : isActive
            ? "#e74c3c"
            : "#2c3e50";
          const fillOpacity = isActive ? 1 : 0.9;
          const radius = (isActive ? 7 : 5).toFixed(2);
          const circleParts = [
            `<circle cx="${x.toFixed(2)}" cy="${y.toFixed(2)}" r="${radius}" fill="${fillColor}" fill-opacity="${fillOpacity}"`
          ];
          if (stuckNow) {
            circleParts.push(' stroke="#ffffff" stroke-width="2"');
          }
          circleParts.push("/>");
          pieces.push(circleParts.join(""));
        });

        if (
          reachOptions.enabled &&
          reachOptions.radius > 0 &&
          displayOptions.showEscapeCircle
        ) {
          const centerPrimary = reachOptions.target.x;
          const centerSecondary =
            axisMode === "xz" ? reachOptions.target.z : reachOptions.target.y;
          const center = projectedToCanvas(centerPrimary, centerSecondary, context);
          const pixelRadius =
            reachOptions.radius * context.scale * Math.max(viewState.zoom, 0);
          if (Number.isFinite(pixelRadius) && pixelRadius > 0) {
            pieces.push(
              `<circle cx="${center.x.toFixed(2)}" cy="${center.y.toFixed(2)}" r="${pixelRadius.toFixed(2)}" fill="#3498db" fill-opacity="0.08" stroke="#2980b9" stroke-width="2" stroke-dasharray="8 6"/>`
            );
            pieces.push(
              `<circle cx="${center.x.toFixed(2)}" cy="${center.y.toFixed(2)}" r="4" fill="#2980b9"/>`
            );
          }
        }

        const origin = projectedToCanvas(0, 0, context);
        pieces.push(
          `<circle cx="${origin.x.toFixed(2)}" cy="${origin.y.toFixed(2)}" r="8" fill="none" stroke="#2c3e50" stroke-width="2"/>`
        );
        pieces.push(
          `<text x="${(origin.x + 10).toFixed(2)}" y="${(origin.y - 8).toFixed(2)}" font-family="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif" font-size="12" fill="#2c3e50">origin</text>`
        );

        if (clipId) {
          pieces.push("</g>");
          pieces.push(
            `<rect x="${cropRect.x.toFixed(2)}" y="${cropRect.y.toFixed(
              2
            )}" width="${cropRect.width.toFixed(2)}" height="${cropRect.height.toFixed(
              2
            )}" fill="none" stroke="rgba(52, 152, 219, 0.6)" stroke-width="1.5" stroke-dasharray="6 4"/>`
          );
        }

        pieces.push("</svg>");
        return pieces.join("\n");
      }

      function buildSVGPath(points, context) {
        if (!points.length) {
          return "";
        }
        const first = projectedToCanvas(points[0].primary, points[0].secondary, context);
        let d = `M ${first.x.toFixed(2)} ${first.y.toFixed(2)}`;
        for (let i = 1; i < points.length; i++) {
          const projected = projectedToCanvas(
            points[i].primary,
            points[i].secondary,
            context
          );
          d += ` L ${projected.x.toFixed(2)} ${projected.y.toFixed(2)}`;
        }
        return d;
      }

      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 500);
      }

      function downloadDataUrl(dataUrl, filename) {
        const link = document.createElement("a");
        link.href = dataUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      function createExportFilename(extension) {
        const timestamp = new Date()
          .toISOString()
          .replace(/[:.]/g, "")
          .slice(0, 15);
        const projection = axisMode.toUpperCase();
        return `timeline_${projection}_${timestamp}.${extension}`;
      }

      function handleWheel(event) {
        if (!globalTimeline.length) {
          return;
        }
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width || 1;
        const scaleY = canvas.height / rect.height || 1;
        const focusX = (event.clientX - rect.left) * scaleX;
        const focusY = (event.clientY - rect.top) * scaleY;
        const factor = event.deltaY < 0 ? 1.1 : 0.9;
        applyZoom(factor, focusX, focusY);
      }

      function handlePointerDown(event) {
        if (event.button !== 0 || !globalTimeline.length) {
          return;
        }
        stopPlayback(false);
        isPanning = true;
        panPointerId = event.pointerId;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width || 1;
        const scaleY = canvas.height / rect.height || 1;
        panStart = {
          clientX: event.clientX,
          clientY: event.clientY,
          offsetX: viewState.offsetX,
          offsetY: viewState.offsetY,
          scaleX,
          scaleY,
        };
        canvas.setPointerCapture(event.pointerId);
        canvas.classList.add("dragging");
      }

      function handlePointerMove(event) {
        if (!isPanning || event.pointerId !== panPointerId) {
          return;
        }
        const dx = (event.clientX - panStart.clientX) * panStart.scaleX;
        const dy = (event.clientY - panStart.clientY) * panStart.scaleY;
        viewState.offsetX = panStart.offsetX + dx;
        viewState.offsetY = panStart.offsetY + dy;
        drawFrame(Number(slider.value));
      }

      function handlePointerUp(event) {
        if (!isPanning) {
          return;
        }
        if (panPointerId !== null && event.pointerId !== panPointerId) {
          return;
        }
        if (panPointerId !== null) {
          try {
            canvas.releasePointerCapture(panPointerId);
          } catch (err) {
            // ignore release failures
          }
        }
        isPanning = false;
        panPointerId = null;
        canvas.classList.remove("dragging");
      }

      function applyZoom(
        factor,
        focusX = canvas.width / 2,
        focusY = canvas.height / 2
      ) {
        if (!globalTimeline.length) {
          return;
        }
        const previousZoom = viewState.zoom;
        const nextZoom = Math.min(
          Math.max(previousZoom * factor, minZoom),
          maxZoom
        );
        if (nextZoom === previousZoom) {
          return;
        }
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const unscaledX =
          (focusX - centerX - viewState.offsetX) / previousZoom + centerX;
        const unscaledY =
          (focusY - centerY - viewState.offsetY) / previousZoom + centerY;
        viewState.zoom = nextZoom;
        viewState.offsetX =
          focusX - (unscaledX - centerX) * viewState.zoom - centerX;
        viewState.offsetY =
          focusY - (unscaledY - centerY) * viewState.zoom - centerY;
        drawFrame(Number(slider.value));
      }

      function resetView(skipRedraw = false) {
        viewState.zoom = 1;
        viewState.offsetX = 0;
        viewState.offsetY = 0;
        if (skipRedraw) {
          updateZoomDisplay();
          return;
        }
        drawFrame(Number(slider.value));
      }

      function updateZoomDisplay() {
        if (!zoomDisplay) {
          return;
        }
        const percent = Math.round(viewState.zoom * 100);
        zoomDisplay.textContent = `Zoom: ${percent}%`;
      }

      function centerView() {
        if (!tracks.length) {
          return;
        }
        if (
          !lastRenderContext ||
          lastRenderContext.axisMode !== axisMode
        ) {
          drawFrame(Number(slider.value));
          if (
            !lastRenderContext ||
            lastRenderContext.axisMode !== axisMode
          ) {
            return;
          }
        }

        const { bounds, margin, scale } = lastRenderContext;
        const baseX = margin + (0 - bounds.minPrimary) * scale;
        const baseY = margin + (bounds.maxSecondary - 0) * scale;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const zoom = viewState.zoom || 1;

        viewState.offsetX = -(baseX - centerX) * zoom;
        viewState.offsetY = -(baseY - centerY) * zoom;
        drawFrame(Number(slider.value));
      }

      async function handleFileSelection(fileList) {
        stopPlayback();
        errorBox.textContent = "";
        if (!fileList || !fileList.length) {
          return;
        }

        const files = Array.from(fileList).filter((file) =>
          file.name.toLowerCase().endsWith(".json")
        );
        if (!files.length) {
          errorBox.textContent = "No JSON files found in the selection.";
          return;
        }

        const parsedTracks = [];
        const failed = [];

        for (const file of files) {
          try {
            const text = await file.text();
            const raw = JSON.parse(text);
            const timeline = extractTimeline(raw);
            if (!timeline.length) {
              failed.push(file.name + " (no coordinates)");
              continue;
            }
            parsedTracks.push({
              id: nextTrackId(),
              name: file.webkitRelativePath || file.name,
              timeline,
              offsets: buildOffsets(timeline),
            });
          } catch (err) {
            console.error("Failed to parse", file.name, err);
            failed.push(file.name + " (parse error)");
          }
        }

        if (!parsedTracks.length) {
          viewer.style.display = "none";
          errorBox.textContent = "Could not load any of the selected files.";
          return;
        }

        colorCache.clear();
        tracks = parsedTracks.map((track, index) => ({
          ...track,
          projections: buildProjections(track.offsets),
          color: getTrackColor(index, track.name),
        }));
        selectedTrackIds = new Set(tracks.map((track) => track.id));
        activeTrackId = tracks[0].id;
        globalTimeline = rebuildGlobalTimeline(tracks);
        markTimelineCoverage();
        resetView(true);
        slider.value = 0;
        evaluateReach();

        refreshTrackList();
        updateControls();
        updateReachSummary();
        drawFrame(0);
        viewer.style.display = "block";

        if (failed.length) {
          errorBox.textContent = `Skipped files: ${failed.join(", ")}`;
        }
      }

      function nextTrackId() {
        trackCounter += 1;
        return `track-${trackCounter}`;
      }

      function refreshTrackList() {
        trackList.innerHTML = "";
        tracks.forEach((track) => {
          const row = document.createElement("div");
          row.className = "track-row";
          row.addEventListener("mouseenter", () => setHoveredTrack(track.id));
          row.addEventListener("mouseleave", () => clearHoveredTrack(track.id));

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = selectedTrackIds.has(track.id);
          checkbox.addEventListener("change", () => {
            handleTrackToggle(track.id, checkbox.checked);
          });

          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "activeTrack";
          radio.checked = track.id === activeTrackId;
          radio.addEventListener("change", () => {
            if (radio.checked) {
              setActiveTrack(track.id);
            }
          });

          const soloBtn = document.createElement("button");
          soloBtn.type = "button";
          const isSoloed = soloMode.enabled && soloMode.trackId === track.id;
          soloBtn.textContent = isSoloed ? "Unfocus" : "Focus";
          soloBtn.title = isSoloed
            ? "Show previously selected tracks"
            : "Show only this track";
          soloBtn.addEventListener("click", () => {
            if (isSoloed) {
              exitSoloMode();
            } else {
              enterSoloMode(track.id);
            }
          });

          const swatch = document.createElement("span");
          swatch.className = "track-swatch";
          swatch.style.backgroundColor = track.color;

          const title = document.createElement("span");
          title.className = "track-name";
          title.textContent = track.name;

          const meta = document.createElement("div");
          meta.className = "track-meta";
          const covers = track.endsEarly
            ? "full timeline: false"
            : "full timeline: true";
          const reachLabel = reachOptions.enabled
            ? ` • escaped radius: ${track.escapedRadius ? "yes" : "no"}`
            : "";
          meta.textContent = `${track.timeline.length} points • ${covers}${reachLabel}`;
          if (reachOptions.enabled) {
            row.style.backgroundColor = track.escapedRadius
              ? "rgba(41, 128, 185, 0.14)"
              : "";
          } else {
            row.style.backgroundColor = "";
          }

          row.appendChild(checkbox);
          row.appendChild(radio);
          row.appendChild(soloBtn);
          row.appendChild(swatch);
          row.appendChild(title);
          row.appendChild(meta);
          trackList.appendChild(row);
        });
      }

      function setHoveredTrack(trackId) {
        if (hoveredTrackId === trackId) {
          return;
        }
        hoveredTrackId = trackId;
        drawFrame(Number(slider.value));
      }

      function clearHoveredTrack(trackId) {
        if (hoveredTrackId !== trackId) {
          return;
        }
        hoveredTrackId = null;
        drawFrame(Number(slider.value));
      }

      function handleTrackToggle(trackId, isChecked) {
        if (soloMode.enabled) {
          exitSoloMode();
        }
        if (isChecked) {
          selectedTrackIds.add(trackId);
        } else {
          selectedTrackIds.delete(trackId);
          if (!selectedTrackIds.size) {
            selectedTrackIds.add(trackId);
            refreshTrackList();
            updateReachSummary();
            return;
          }
          if (trackId === activeTrackId) {
            const replacement = tracks.find((track) =>
              selectedTrackIds.has(track.id)
            );
            if (replacement) {
              setActiveTrack(replacement.id);
              return;
            }
          }
        }
        updateReachSummary();
        drawFrame(Number(slider.value));
      }

      function setActiveTrack(trackId) {
        if (activeTrackId === trackId) {
          return;
        }
        activeTrackId = trackId;
        if (!selectedTrackIds.has(trackId)) {
          selectedTrackIds.add(trackId);
        }
        stopPlayback(false);
        refreshTrackList();
        updateControls();
        updateReachSummary();
        drawFrame(Number(slider.value));
      }

      function enterSoloMode(trackId) {
        if (soloMode.enabled && soloMode.trackId === trackId) {
          exitSoloMode();
          return;
        }
        soloMode.enabled = true;
        soloMode.trackId = trackId;
        soloMode.prevSelection = new Set(selectedTrackIds);
        selectedTrackIds = new Set([trackId]);
        setActiveTrack(trackId);
        refreshTrackList();
        updateReachSummary();
        drawFrame(Number(slider.value));
      }

      function exitSoloMode() {
        if (!soloMode.enabled) return;
        if (soloMode.prevSelection && soloMode.prevSelection.size) {
          selectedTrackIds = new Set(soloMode.prevSelection);
        } else if (soloMode.trackId) {
          selectedTrackIds = new Set([soloMode.trackId]);
        }
        soloMode.enabled = false;
        soloMode.trackId = null;
        soloMode.prevSelection = null;
        refreshTrackList();
        updateReachSummary();
        drawFrame(Number(slider.value));
      }

      function getActiveTrack() {
        return tracks.find((track) => track.id === activeTrackId) || null;
      }

      function updateControls() {
        const totalFrames = globalTimeline.length;
        if (!totalFrames) {
          slider.disabled = true;
          slider.min = 0;
          slider.max = 0;
          slider.value = 0;
          playPause.disabled = true;
          syncExportControls(false);
          return;
        }
        slider.disabled = false;
        slider.min = 0;
        slider.max = Math.max(totalFrames - 1, 0);
        const currentValue = Number(slider.value);
        slider.value = Number.isFinite(currentValue)
          ? Math.min(Math.max(currentValue, 0), slider.max)
          : 0;
        playPause.disabled = totalFrames < 2;
        syncExportControls(true);
      }

      function syncExportControls(enabled) {
        exportPngButton.disabled = !enabled;
        exportSvgButton.disabled = !enabled;
        centerViewButton.disabled = !enabled;
      }

      function startPlayback() {
        if (globalTimeline.length < 2) {
          return;
        }
        isPlaying = true;
        playPause.textContent = "Pause";
        const startIndex = Number(slider.value);
        animateFrom(startIndex);
      }

      function animateFrom(index) {
        drawFrame(index);
        slider.value = index;
        if (!isPlaying) {
          return;
        }
        if (!globalTimeline.length) {
          stopPlayback();
          return;
        }
        const next = (index + 1) % globalTimeline.length;
        const delay = computeDelay(index, next);
        animationId = setTimeout(() => animateFrom(next), delay);
      }

      function stopPlayback(resetButton = true) {
        if (animationId !== null) {
          clearTimeout(animationId);
          animationId = null;
        }
        isPlaying = false;
        if (resetButton) {
          playPause.textContent = "Play";
        }
      }

      function computeDelay(currentIndex, nextIndex) {
        if (!globalTimeline.length) {
          return 500;
        }
        const current = globalTimeline[currentIndex];
        const next = globalTimeline[nextIndex];
        const delta = Math.abs(next - current);
        if (!Number.isFinite(delta) || delta === 0) {
          return 500;
        }
        return Math.min(Math.max(delta, 200), 3000);
      }

      function getComparableTimestamp(entry, fallbackIndex) {
        if (!entry) {
          return fallbackIndex;
        }
        return Number.isFinite(entry.numericTimestamp)
          ? entry.numericTimestamp
          : fallbackIndex;
      }

      function drawFrame(rawIndex) {
        const totalFrames = globalTimeline.length;
        if (!totalFrames) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          updateDetails(null, null, null, null);
          playPause.textContent = "Play";
          updateZoomDisplay();
          lastRenderContext = null;
          return;
        }

        const clampedIndex = Math.min(Math.max(rawIndex, 0), totalFrames - 1);
        slider.value = clampedIndex;
        const targetTimestamp = globalTimeline[clampedIndex];

        const visibleTracks = tracks.filter((track) =>
          selectedTrackIds.has(track.id)
        );
        const active = getActiveTrack();

        if (!visibleTracks.length || !active) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          updateDetails(null, null, null, null);
          playPause.textContent = isPlaying ? "Pause" : "Play";
          updateZoomDisplay();
          lastRenderContext = null;
          return;
        }

        const trackHighlights = visibleTracks.map((track) => {
          const highlightIndex = findNearestIndex(
            track,
            targetTimestamp,
            clampedIndex
          );
          return { track, highlightIndex };
        });

        renderScene(trackHighlights, targetTimestamp, clampedIndex);

        const activeHighlight = trackHighlights.find(
          (item) => item.track.id === activeTrackId
        ) || {
          track: active,
          highlightIndex: findNearestIndex(
            active,
            targetTimestamp,
            clampedIndex
          ),
        };

        const safeIndex = Math.min(
          Math.max(activeHighlight.highlightIndex, 0),
          active.timeline.length - 1
        );
        const entry = active.timeline[safeIndex];
        const offset = active.offsets[safeIndex];
        updateDetails(active, safeIndex, entry, offset);

        playPause.textContent = isPlaying ? "Pause" : "Play";
        updateZoomDisplay();
      }

      function renderScene(trackHighlights, targetTimestamp, globalIndex) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!trackHighlights.length) {
          lastRenderContext = null;
          return;
        }

        const margin = 40;
        const width = canvas.width - margin * 2;
        const height = canvas.height - margin * 2;

        const tracksForBounds = trackHighlights.map((item) => item.track);
        const naturalBounds = computeBounds(tracksForBounds);
        let bounds = { ...naturalBounds };

        if (displayOptions.crop.enabled) {
          const center = computeCropCenter();
          const halfSize = (displayOptions.crop.size || 1) / 2;
          bounds = {
            minPrimary: center.primary - halfSize,
            maxPrimary: center.primary + halfSize,
            minSecondary: center.secondary - halfSize,
            maxSecondary: center.secondary + halfSize,
          };
        }

        const spanPrimary = bounds.maxPrimary - bounds.minPrimary || 1;
        const spanSecondary = bounds.maxSecondary - bounds.minSecondary || 1;
        const scale = Math.min(width / spanPrimary, height / spanSecondary);

        const context = {
          bounds,
          margin,
          scale,
        };

        lastRenderContext = { ...context, axisMode };

        const cropRect =
          displayOptions.crop.enabled && displayOptions.crop.size > 0
            ? computeCropRect(context)
            : null;
        let clippingApplied = false;
        if (
          cropRect &&
          Number.isFinite(cropRect.width) &&
          Number.isFinite(cropRect.height) &&
          cropRect.width > 0 &&
          cropRect.height > 0
        ) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(cropRect.x, cropRect.y, cropRect.width, cropRect.height);
          ctx.clip();
          clippingApplied = true;
        }

        ctx.save();
        ctx.strokeStyle = "#e0e0e0";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        if (bounds.minSecondary <= 0 && bounds.maxSecondary >= 0) {
          const horizontalStart = projectedToCanvas(
            bounds.minPrimary,
            0,
            context
          );
          const horizontalEnd = projectedToCanvas(
            bounds.maxPrimary,
            0,
            context
          );
          ctx.beginPath();
          ctx.moveTo(horizontalStart.x, horizontalStart.y);
          ctx.lineTo(horizontalEnd.x, horizontalEnd.y);
          ctx.stroke();
        }
        if (bounds.minPrimary <= 0 && bounds.maxPrimary >= 0) {
          const verticalStart = projectedToCanvas(
            0,
            bounds.minSecondary,
            context
          );
          const verticalEnd = projectedToCanvas(
            0,
            bounds.maxSecondary,
            context
          );
          ctx.beginPath();
          ctx.moveTo(verticalStart.x, verticalStart.y);
          ctx.lineTo(verticalEnd.x, verticalEnd.y);
          ctx.stroke();
        }
        ctx.restore();

        trackHighlights.forEach(({ track, highlightIndex }) => {
          renderTrack(
            track,
            highlightIndex,
            track.id === activeTrackId,
            context,
            targetTimestamp,
            globalIndex
          );
        });

        if (
          reachOptions.enabled &&
          reachOptions.radius > 0 &&
          displayOptions.showEscapeCircle
        ) {
          drawReachCircle(context);
        }

        const origin = projectedToCanvas(0, 0, context);
        ctx.strokeStyle = "#2c3e50";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, 8, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = "#2c3e50";
        ctx.font = "12px system-ui";
        ctx.fillText("origin", origin.x + 10, origin.y - 8);

        if (clippingApplied) {
          ctx.restore();
        }

        if (cropRect && cropRect.width > 0 && cropRect.height > 0) {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = "rgba(52, 152, 219, 0.6)";
          ctx.setLineDash([6, 4]);
          ctx.strokeRect(cropRect.x, cropRect.y, cropRect.width, cropRect.height);
          ctx.setLineDash([]);
          ctx.restore();
        }
      }

      function projectOffset(offset) {
        return {
          primary: offset.dx,
          secondary: axisMode === "xz" ? offset.dz : offset.dy,
        };
      }

      function projectedToCanvas(primary, secondary, context) {
        const baseX =
          context.margin +
          (primary - context.bounds.minPrimary) * context.scale;
        const baseY =
          context.margin +
          (context.bounds.maxSecondary - secondary) * context.scale;
        return applyViewTransform(baseX, baseY);
      }

      function computeCropCenter() {
        if (displayOptions.crop.centerMode === "escape" && reachOptions.enabled) {
          return {
            primary: reachOptions.target.x,
            secondary:
              axisMode === "xz" ? reachOptions.target.z : reachOptions.target.y,
          };
        }
        const active = getActiveTrack();
        if (active && active.offsets && active.offsets.length) {
          const first = active.offsets[0];
          return {
            primary: first.dx,
            secondary: axisMode === "xz" ? first.dz : first.dy,
          };
        }
        return { primary: 0, secondary: 0 };
      }

      function computeCropRect(context) {
        const topLeft = projectedToCanvas(
          context.bounds.minPrimary,
          context.bounds.maxSecondary,
          context
        );
        const bottomRight = projectedToCanvas(
          context.bounds.maxPrimary,
          context.bounds.minSecondary,
          context
        );
        const x = Math.min(topLeft.x, bottomRight.x);
        const y = Math.min(topLeft.y, bottomRight.y);
        const width = Math.abs(bottomRight.x - topLeft.x);
        const height = Math.abs(bottomRight.y - topLeft.y);
        return { x, y, width, height };
      }

      function applyViewTransform(x, y) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const zoomedX =
          (x - centerX) * viewState.zoom + centerX + viewState.offsetX;
        const zoomedY =
          (y - centerY) * viewState.zoom + centerY + viewState.offsetY;
        return { x: zoomedX, y: zoomedY };
      }

      function applyPathTransform(context) {
        const baseScale = context.scale || 1;
        const translateX =
          context.margin - context.bounds.minPrimary * baseScale;
        const translateY =
          context.margin + context.bounds.maxSecondary * baseScale;

        ctx.translate(viewState.offsetX, viewState.offsetY);
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(viewState.zoom, viewState.zoom);
        ctx.translate(-canvas.width / 2, -canvas.height / 2);
        ctx.transform(baseScale, 0, 0, -baseScale, translateX, translateY);
      }

      function renderTrack(
        track,
        highlightIndex,
        isActive,
        context,
        targetTimestamp,
        globalIndex
      ) {
        const projection = track.projections?.[axisMode];
        if (!projection || !projection.points.length) {
          return;
        }

        const isHovered = hoveredTrackId === track.id;

        if (displayOptions.showPaths) {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          applyPathTransform(context);
          ctx.strokeStyle = track.color;
          ctx.globalAlpha = isActive || isHovered ? 1 : 0.55;
          ctx.lineJoin = "round";
          const baseWidth = isActive ? 2.5 : 1.8;
          const widthBoost = isHovered && !isActive ? 1.45 : isHovered ? 1.2 : 1;
          const scaleFactor = context.scale * viewState.zoom || 1;
          ctx.lineWidth = (baseWidth * widthBoost) / scaleFactor;
          if (isHovered) {
            ctx.shadowColor = track.color;
            ctx.shadowBlur = 6 / Math.max(viewState.zoom, 0.5);
          }
          ctx.stroke(projection.path);
          ctx.restore();
        }

        const safeIndex = Math.min(
          Math.max(highlightIndex, 0),
          projection.points.length - 1
        );
        const highlightPoint = projection.points[safeIndex];
        if (!highlightPoint) {
          return;
        }
        const { x, y } = projectedToCanvas(
          highlightPoint.primary,
          highlightPoint.secondary,
          context
        );
        ctx.save();
        const ended = hasTrackEndedAt(track, targetTimestamp, globalIndex);
        const stuckNow = !ended && isStuckAt(track, safeIndex);
        // Color rules: ended -> yellow, stuck -> purple, active -> red, otherwise -> dark slate
        ctx.fillStyle = ended
          ? "#f1c40f"
          : stuckNow
          ? "#8e44ad"
          : isActive
          ? "#e74c3c"
          : "#2c3e50";
        ctx.globalAlpha = isHovered || isActive ? 1 : 0.9;
        ctx.beginPath();
        const radius = isActive ? 7 : isHovered ? 6 : 5;
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        if (stuckNow) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#ffffff";
          ctx.stroke();
        } else if (isHovered && !ended) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#ffffff";
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawReachCircle(context) {
        const centerPrimary = reachOptions.target.x;
        const centerSecondary =
          axisMode === "xz" ? reachOptions.target.z : reachOptions.target.y;
        const center = projectedToCanvas(
          centerPrimary,
          centerSecondary,
          context
        );
        const pixelRadius =
          reachOptions.radius * context.scale * Math.max(viewState.zoom, 0);
        if (!Number.isFinite(pixelRadius) || pixelRadius <= 0) {
          return;
        }
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.beginPath();
        ctx.fillStyle = "rgba(52, 152, 219, 0.08)";
        ctx.strokeStyle = "rgba(41, 128, 185, 0.9)";
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 6]);
        ctx.arc(center.x, center.y, pixelRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.fillStyle = "rgba(41, 128, 185, 0.9)";
        ctx.arc(center.x, center.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // --- Stuck detection helpers ---
      function mean(arr) {
        if (!arr.length) return 0;
        let s = 0;
        for (let i = 0; i < arr.length; i++) s += arr[i];
        return s / arr.length;
      }

      function stddev(arr) {
        if (arr.length < 2) return 0;
        const m = mean(arr);
        let v = 0;
        for (let i = 0; i < arr.length; i++) {
          const d = arr[i] - m;
          v += d * d;
        }
        v /= arr.length; // population variance
        return Math.sqrt(v);
      }

      // Determine if a track is stuck at a given index using the current axis projection.
      // Uses the last STUCK_WINDOW points (or fewer if near the beginning) and combines
      // stddev of primary and secondary by Euclidean norm.
      function isStuckAt(track, index) {
        const projection = track.projections?.[axisMode];
        if (!projection || !projection.points.length) return false;
        const end = Math.min(index, projection.points.length - 1);
        const start = Math.max(0, end - (STUCK_WINDOW - 1));
        const slice = projection.points.slice(start, end + 1);
        if (slice.length < 3) return false;

        const prim = new Array(slice.length);
        const sec = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
          prim[i] = slice[i].primary;
          sec[i] = slice[i].secondary;
        }
        const s1 = stddev(prim);
        const s2 = stddev(sec);
        const combined = Math.hypot(s1, s2);
        return combined < STUCK_STD_THRESHOLD;
      }

      function hasTrackEndedAt(track, targetTimestamp, globalIndex) {
        const length = track.timeline.length;
        if (!length) {
          return true;
        }
        const lastIndex = length - 1;
        if (globalIndex <= lastIndex) {
          const numericTarget = Number(targetTimestamp);
          const numericLast = Number(
            getComparableTimestamp(track.timeline[lastIndex], lastIndex)
          );
          if (Number.isFinite(numericTarget) && Number.isFinite(numericLast)) {
            return numericTarget > numericLast;
          }
          return false;
        }
        return true;
      }

      function computeBounds(visibleTracks) {
        let minPrimary = Infinity;
        let maxPrimary = -Infinity;
        let minSecondary = Infinity;
        let maxSecondary = -Infinity;

        visibleTracks.forEach((track) => {
          const projection = track.projections?.[axisMode];
          if (!projection || !projection.points.length) {
            return;
          }
          const bounds = projection.bounds;
          minPrimary = Math.min(minPrimary, bounds.minPrimary);
          maxPrimary = Math.max(maxPrimary, bounds.maxPrimary);
          minSecondary = Math.min(minSecondary, bounds.minSecondary);
          maxSecondary = Math.max(maxSecondary, bounds.maxSecondary);
        });

        if (
          !visibleTracks.length ||
          !Number.isFinite(minPrimary) ||
          !Number.isFinite(minSecondary)
        ) {
          minPrimary = maxPrimary = minSecondary = maxSecondary = 0;
        }

        const padding = 0.5;
        return {
          minPrimary: minPrimary - padding,
          maxPrimary: maxPrimary + padding,
          minSecondary: minSecondary - padding,
          maxSecondary: maxSecondary + padding,
        };
      }

      function findNearestIndex(track, targetTimestamp, fallbackIndex) {
        if (!track.timeline.length) {
          return 0;
        }
        if (!Number.isFinite(targetTimestamp)) {
          return Math.min(fallbackIndex, track.timeline.length - 1);
        }
        let bestIndex = 0;
        let bestDelta = Infinity;
        track.timeline.forEach((entry, idx) => {
          const candidate = getComparableTimestamp(entry, idx);
          const delta = Math.abs(candidate - targetTimestamp);
          if (delta < bestDelta) {
            bestDelta = delta;
            bestIndex = idx;
          }
        });
        return bestIndex;
      }

      function updateDetails(track, index, entry, offset) {
        if (!track || !entry || !offset) {
          trackBox.textContent = "Track: (none)";
          timestampBox.textContent = "Timestamp: -";
          absoluteBox.textContent = "Absolute: -";
          relativeBox.textContent = "Offset: -";
          return;
        }
        const coverageLabel = track.endsEarly
          ? "full timeline: false"
          : "full timeline: true";
        const stuckLabel = isStuckAt(track, index)
          ? "stuck: true"
          : "stuck: false";
        trackBox.textContent = `Track: ${track.name} (${track.timeline.length} points, ${coverageLabel}, ${stuckLabel})`;
        timestampBox.textContent = `Timestamp: ${entry.originalTimestamp}`;
        absoluteBox.textContent = `Absolute: x=${entry.x.toFixed(
          2
        )}, y=${entry.y.toFixed(2)}, z=${entry.z.toFixed(2)}`;
        relativeBox.textContent = `Offset: dx=${offset.dx.toFixed(
          2
        )}, dy=${offset.dy.toFixed(2)}, dz=${offset.dz.toFixed(2)}`;
      }

      function markTimelineCoverage() {
        const globalLength = globalTimeline.length;
        const globalLast = globalLength
          ? globalTimeline[globalLength - 1]
          : null;
        const numericGlobalLast = Number(globalLast);
        const hasNumericGlobal = Number.isFinite(numericGlobalLast);

        tracks.forEach((track) => {
          const lastIndex = track.timeline.length - 1;
          if (lastIndex < 0) {
            track.endsEarly = true;
            return;
          }
          if (!globalLength) {
            track.endsEarly = false;
            return;
          }
          const lastComparable = getComparableTimestamp(
            track.timeline[lastIndex],
            lastIndex
          );
          const numericLast = Number(lastComparable);
          let endsEarly = track.timeline.length < globalLength;
          if (!endsEarly && hasNumericGlobal && Number.isFinite(numericLast)) {
            endsEarly = numericLast < numericGlobalLast;
          }
          track.endsEarly = endsEarly;
        });
      }

      function rebuildGlobalTimeline(trackList) {
        const moments = new Set();
        let fallbackLength = 0;
        trackList.forEach((track) => {
          fallbackLength = Math.max(fallbackLength, track.timeline.length);
          track.timeline.forEach((entry, idx) => {
            const value = getComparableTimestamp(entry, idx);
            moments.add(value);
          });
        });
        const sorted = Array.from(moments)
          .filter((value) => Number.isFinite(value))
          .sort((a, b) => a - b);
        if (sorted.length) {
          return sorted;
        }
        return Array.from({ length: fallbackLength }, (_, idx) => idx);
      }

      function extractTimeline(raw) {
        const rows = [];

        function pushEntry(entry, index, fallbackKey = null) {
          const coords = extractCoordinates(entry);
          if (!coords) {
            return;
          }
          const timestamp = readTimestamp(entry, index, fallbackKey);
          rows.push({
            originalTimestamp: timestamp.display,
            numericTimestamp: timestamp.numeric,
            x: coords.x,
            y: coords.y,
            z: coords.z,
          });
        }

        function processArray(array, baseKey = null) {
          array.forEach((entry, index) => {
            const fallbackKey = baseKey ? `${baseKey}[${index}]` : null;
            pushEntry(entry, index, fallbackKey);
          });
        }

        if (Array.isArray(raw)) {
          processArray(raw);
        } else if (raw && typeof raw === "object") {
          Object.entries(raw).forEach(([key, value], index) => {
            if (Array.isArray(value)) {
              processArray(value, key);
              return;
            }
            pushEntry(value, index, key);
          });
        }
        const allNumeric = rows.every((row) =>
          Number.isFinite(row.numericTimestamp)
        );
        if (allNumeric) {
          rows.sort((a, b) => a.numericTimestamp - b.numericTimestamp);
        }
        return rows;
      }

      function extractCoordinates(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }
        const direct = pickAxes(entry);
        if (direct) {
          return direct;
        }
        const coordinateWrappers = [
          "coordinate",
          "coordinates",
          "coords",
          "pos",
          "position",
          "location",
          "loc",
          "point",
          "座標",
        ];
        for (const key of coordinateWrappers) {
          if (entry[key] && typeof entry[key] === "object") {
            const nested = pickAxes(entry[key]);
            if (nested) {
              return nested;
            }
          }
        }
        return null;
      }

      function pickAxes(candidate) {
        if (!candidate || typeof candidate !== "object") {
          return null;
        }
        const x = readAxis(candidate, ["x", "X"]);
        const y = readAxis(candidate, ["y", "Y"]);
        const z = readAxis(candidate, ["z", "Z"]);
        if ([x, y, z].every((value) => Number.isFinite(value))) {
          return { x, y, z };
        }
        return null;
      }

      function readAxis(obj, keys) {
        for (const key of keys) {
          if (typeof obj[key] === "number") {
            return obj[key];
          }
          if (typeof obj[key] === "string") {
            const numeric = Number(obj[key]);
            if (Number.isFinite(numeric)) {
              return numeric;
            }
          }
        }
        return NaN;
      }

      function readTimestamp(entry, index, fallbackKey = null) {
        const candidates = [
          "timestamp",
          "time",
          "tick",
          "date",
          "step",
          "タイムスタンプ",
        ];
        for (const key of candidates) {
          if (entry && Object.prototype.hasOwnProperty.call(entry, key)) {
            const value = entry[key];
            if (Number.isFinite(Number(value))) {
              return { display: String(value), numeric: Number(value) };
            }
            return { display: String(value), numeric: index };
          }
        }
        if (fallbackKey !== null) {
          if (Number.isFinite(Number(fallbackKey))) {
            return { display: fallbackKey, numeric: Number(fallbackKey) };
          }
          return { display: fallbackKey, numeric: index };
        }
        return { display: `#${index}`, numeric: index };
      }

      function buildOffsets(rows) {
        const [first] = rows;
        return rows.map((row) => ({
          dx: row.x - first.x,
          dy: row.y - first.y,
          dz: row.z - first.z,
        }));
      }

      function buildProjections(offsets) {
        const createProjection = (secondaryKey) => {
          if (!offsets.length) {
            return {
              points: [],
              path: new Path2D(),
              bounds: {
                minPrimary: 0,
                maxPrimary: 0,
                minSecondary: 0,
                maxSecondary: 0,
              },
            };
          }
          const points = offsets.map((offset) => ({
            primary: offset.dx,
            secondary: offset[secondaryKey],
          }));
          const path = new Path2D();
          points.forEach((point, index) => {
            if (index === 0) {
              path.moveTo(point.primary, point.secondary);
            } else {
              path.lineTo(point.primary, point.secondary);
            }
          });
          const bounds = points.reduce(
            (acc, point) => ({
              minPrimary: Math.min(acc.minPrimary, point.primary),
              maxPrimary: Math.max(acc.maxPrimary, point.primary),
              minSecondary: Math.min(acc.minSecondary, point.secondary),
              maxSecondary: Math.max(acc.maxSecondary, point.secondary),
            }),
            {
              minPrimary: Infinity,
              maxPrimary: -Infinity,
              minSecondary: Infinity,
              maxSecondary: -Infinity,
            }
          );
          return { points, path, bounds };
        };

        return {
          xy: createProjection("dy"),
          xz: createProjection("dz"),
        };
      }
    </script>
  </body>
</html>
