<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Stuck Detection Report</title>
    <style>
      :root {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #1b1b1b;
        background-color: #f7f7f7;
      }
      body {
        margin: 0;
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-height: 100vh;
        box-sizing: border-box;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 1.6rem;
      }
      h2 {
        margin: 12px 0;
        font-size: 1.1rem;
      }
      p {
        margin: 0;
        color: #555;
      }
      label {
        font-weight: 600;
        display: inline-flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
      }
      .panel {
        background: white;
        border-radius: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        padding: 20px 24px;
      }
      .loader-area {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-top: 16px;
      }
      .loader-area input[type="file"] {
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 6px;
        background: #fafafa;
      }
      .options {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-top: 16px;
      }
      .options label input {
        width: 120px;
        padding: 4px 6px;
        border-radius: 4px;
        border: 1px solid #bbb;
        background: #fff;
      }
      .summary-options {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin: 12px 0;
        font-size: 0.9rem;
        color: #333;
      }
      .summary-options label {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-weight: 600;
      }
      .summary-options input[type="checkbox"] {
        width: 16px;
        height: 16px;
      }
      .export-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin: 12px 0;
      }
      .export-controls button {
        padding: 6px 12px;
        font-size: 0.95rem;
        border-radius: 6px;
        cursor: pointer;
        border: 1px solid #bbb;
        background: #fafafa;
      }
      .export-controls button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #status {
        margin-top: 12px;
        color: #8e44ad;
        white-space: pre-wrap;
      }
      .table-wrapper {
        overflow-x: auto;
        border-radius: 8px;
        border: 1px solid #eee;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 760px;
      }
      thead {
        background: #f0f0f0;
      }
      th,
      td {
        padding: 10px 12px;
        text-align: left;
        border-bottom: 1px solid #e5e5e5;
        font-size: 0.92rem;
        color: #333;
      }
      tbody tr:nth-child(even) {
        background: #fafafa;
      }
      code {
        font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco,
          Consolas, "Liberation Mono", "Courier New", monospace;
        background: #f1f1f1;
        padding: 2px 4px;
        border-radius: 4px;
      }
      .note {
        margin-top: 8px;
        font-size: 0.85rem;
        color: #777;
      }
      .hidden {
        display: none !important;
      }
      .link-area {
        margin-top: 12px;
        font-size: 0.9rem;
      }
      .link-area a {
        color: #0b5ed7;
        text-decoration: none;
      }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        margin: 16px 0;
      }
      .stat-card {
        border: 1px solid #e0e0e0;
        border-radius: 10px;
        padding: 12px 14px;
        background: #fafbff;
      }
      .stat-card strong {
        display: block;
        font-size: 1.5rem;
        color: #111;
      }
      .stat-card span {
        font-size: 0.9rem;
        color: #555;
      }
    </style>
  </head>
  <body>
    <div class="panel">
      <h1>Stuck Detection Report</h1>
      <p>
        CSV / JSON ログから x-z 平面での 2D 変動を解析し、750 step 内における
        標準偏差の大きい方が 2 以下になった区間を STUCK として検出します。
      </p>
      <div class="link-area">
        <a href="../index.html">座標ビューアに戻る</a>
        &nbsp;|&nbsp;
        <a href="./index.html">エスケープ解析はこちら</a>
      </div>
      <div class="loader-area">
        <label>
          ファイルを選択
          <input
            type="file"
            id="fileInput"
            accept=".json,.csv,application/json,text/csv"
            multiple
          />
        </label>
      </div>
      <div class="options">
        <label>
          ウィンドウサイズ (step)
          <input type="number" id="windowSizeInput" value="750" min="50" />
        </label>
        <label>
          標準偏差の閾値
          <input
            type="number"
            id="stdThresholdInput"
            value="2"
            min="0"
            step="0.1"
          />
        </label>
      </div>
      <p class="note">
        CSV の列名は <code>step</code>/<code>time</code> などの時刻カラムと、
        <code>x</code>/<code>y</code>/<code>z</code> を含めてください。
        JSON は既存ビューアと同じ形式に対応しています。
      </p>
      <div id="status"></div>
    </div>

    <div id="resultsPanel" class="panel hidden">
      <h2>概要</h2>
      <div class="summary-options">
        <label>
          <input type="checkbox" id="hideNoStuck" />
          STUCK がないトラックを除外
        </label>
      </div>
      <div class="stats-grid">
        <div class="stat-card">
          <span>STUCK総回数</span>
          <strong id="totalStuckCount">-</strong>
        </div>
        <div class="stat-card">
          <span>STUCK経験トラック数</span>
          <strong id="stuckEpisodeCount">-</strong>
        </div>
        <div class="stat-card">
          <span>読み込んだトラック数</span>
          <strong id="totalTrackCount">-</strong>
        </div>
        <div class="stat-card">
          <span>ポイント不足トラック数</span>
          <strong id="insufficientTrackCount">-</strong>
        </div>
      </div>
      <div class="export-controls">
        <button id="exportSummary" type="button" disabled>
          概要をCSV出力
        </button>
        <button id="exportEvents" type="button" disabled>
          STUCKイベントをCSV出力
        </button>
      </div>
      <div id="summaryContainer" class="table-wrapper"></div>
      <h2>STUCKイベント一覧</h2>
      <div id="eventsContainer" class="table-wrapper"></div>
      <p class="note">
        秒換算は 20 tick = 1 秒として計算しています。ウィンドウサイズと閾値は
        解析途中でも変更できます。
      </p>
    </div>

    <script>
      const fileInput = document.getElementById("fileInput");
      const windowSizeInput = document.getElementById("windowSizeInput");
      const stdThresholdInput = document.getElementById("stdThresholdInput");
      const statusBox = document.getElementById("status");
      const resultsPanel = document.getElementById("resultsPanel");
      const summaryContainer = document.getElementById("summaryContainer");
      const eventsContainer = document.getElementById("eventsContainer");
      const exportSummaryButton = document.getElementById("exportSummary");
      const exportEventsButton = document.getElementById("exportEvents");
      const hideNoStuckCheckbox = document.getElementById("hideNoStuck");
      const totalStuckCountBox = document.getElementById("totalStuckCount");
      const stuckEpisodeCountBox = document.getElementById("stuckEpisodeCount");
      const totalTrackCountBox = document.getElementById("totalTrackCount");
      const insufficientTrackCountBox = document.getElementById(
        "insufficientTrackCount"
      );

      let tracks = [];
      let lastAnalyses = [];
      let lastSummaryTable = { headers: [], rows: [] };
      let lastEventsTable = { headers: [], rows: [] };

      const summaryPreferences = { hideNoStuck: false };

      fileInput.addEventListener("change", async (event) => {
        await loadTracks(event.target.files);
      });

      [windowSizeInput, stdThresholdInput].forEach((input) => {
        input.addEventListener("input", () => {
          if (!tracks.length) {
            return;
          }
          runAnalysis();
        });
      });

      hideNoStuckCheckbox.addEventListener("change", () => {
        summaryPreferences.hideNoStuck = hideNoStuckCheckbox.checked;
        renderTables();
      });

      exportSummaryButton.addEventListener("click", () => {
        if (lastSummaryTable.rows.length) {
          exportCsv("stuck-summary.csv", lastSummaryTable);
        }
      });

      exportEventsButton.addEventListener("click", () => {
        if (lastEventsTable.rows.length) {
          exportCsv("stuck-events.csv", lastEventsTable);
        }
      });

      summaryPreferences.hideNoStuck = hideNoStuckCheckbox.checked;
      syncExportState();

      async function loadTracks(fileList) {
        tracks = [];
        statusBox.textContent = "";
        if (!fileList || !fileList.length) {
          resetResults();
          statusBox.textContent = "ファイルを選択してください。";
          return;
        }

        const files = Array.from(fileList);
        const errors = [];
        let counter = 0;

        for (const file of files) {
          const lower = file.name.toLowerCase();
          if (!lower.endsWith(".json") && !lower.endsWith(".csv")) {
            errors.push(`${file.name}: 未対応の拡張子です`);
            continue;
          }
          try {
            const text = await file.text();
            const raw = lower.endsWith(".json")
              ? JSON.parse(text)
              : parseCsv(text);
            const timeline = extractTimeline(raw);
            if (!timeline.length) {
              errors.push(`${file.name}: 座標データが見つかりませんでした`);
              continue;
            }
            tracks.push({
              id: `track-${counter++}`,
              name: file.webkitRelativePath || file.name,
              timeline,
            });
          } catch (err) {
            console.error("Failed to parse", file.name, err);
            errors.push(`${file.name}: 読み込みに失敗しました`);
          }
        }

        if (!tracks.length) {
          resetResults();
          statusBox.textContent =
            errors.length > 0
              ? errors.join("\n")
              : "処理できるファイルがありませんでした。";
          return;
        }

        statusBox.textContent =
          errors.length > 0 ? errors.join("\n") : "";
        runAnalysis();
      }

      function runAnalysis() {
        const options = readOptions();
        lastAnalyses = tracks.map((track) => analyzeTrack(track, options));
        renderTables();
        resultsPanel.classList.remove("hidden");
      }

      function readOptions() {
        const windowRaw = Number(windowSizeInput.value);
        const thresholdRaw = Number(stdThresholdInput.value);
        const windowSize = Number.isFinite(windowRaw)
          ? Math.max(2, Math.floor(windowRaw))
          : 750;
        const stdThreshold = Number.isFinite(thresholdRaw)
          ? Math.max(0, thresholdRaw)
          : 2;

        if (windowSize !== windowRaw) {
          windowSizeInput.value = String(windowSize);
        }
        if (stdThreshold !== thresholdRaw) {
          stdThresholdInput.value = String(stdThreshold);
        }

        return {
          windowSize,
          stdThreshold,
        };
      }

      function resetResults() {
        lastAnalyses = [];
        lastSummaryTable = { headers: [], rows: [] };
        lastEventsTable = { headers: [], rows: [] };
        summaryContainer.innerHTML = "";
        eventsContainer.innerHTML = "";
        resultsPanel.classList.add("hidden");
        updateOverviewStats(null);
        syncExportState();
      }

      function renderTables() {
        if (!lastAnalyses.length) {
          summaryContainer.innerHTML = "<p>データがありません。</p>";
          eventsContainer.innerHTML = "<p>STUCKイベントはありません。</p>";
          lastSummaryTable = { headers: [], rows: [] };
          lastEventsTable = { headers: [], rows: [] };
          updateOverviewStats(null);
          syncExportState();
          return;
        }
        updateOverviewStats(lastAnalyses);
        lastSummaryTable = buildSummaryTableData(
          lastAnalyses,
          summaryPreferences
        );
        lastEventsTable = buildEventsTableData(lastAnalyses);
        renderSummary(lastSummaryTable);
        renderEvents(lastEventsTable);
        syncExportState();
      }

      function syncExportState() {
        exportSummaryButton.disabled = !lastSummaryTable.rows.length;
        exportEventsButton.disabled = !lastEventsTable.rows.length;
      }

      function updateOverviewStats(analyses) {
        if (!analyses || !analyses.length) {
          totalStuckCountBox.textContent = "-";
          stuckEpisodeCountBox.textContent = "-";
          totalTrackCountBox.textContent = "-";
          insufficientTrackCountBox.textContent = "-";
          return;
        }
        const totalEventCount = analyses.reduce(
          (sum, analysis) => sum + analysis.events.length,
          0
        );
        const episodesWithStuck = analyses.filter(
          (analysis) => analysis.events.length > 0
        ).length;
        const insufficientCount = analyses.filter(
          (analysis) => analysis.insufficientPoints
        ).length;
        totalStuckCountBox.textContent = formatNumber(totalEventCount);
        stuckEpisodeCountBox.textContent = `${formatNumber(
          episodesWithStuck
        )} / ${formatNumber(analyses.length)}`;
        totalTrackCountBox.textContent = formatNumber(analyses.length);
        insufficientTrackCountBox.textContent = formatNumber(insufficientCount);
      }

      function buildSummaryTableData(analyses, preferences) {
        const headers = [
          "トラック",
          "ポイント数",
          "STUCK回数",
          "最初のSTUCK開始",
          "STUCK総サンプル数",
          "STUCK総tick",
          "備考",
        ];
        const rows = analyses
          .filter(
            (analysis) =>
              !preferences.hideNoStuck || analysis.events.length > 0
          )
          .map((analysis) => {
            const firstEvent = analysis.events[0] || null;
            const note = analysis.insufficientPoints
              ? `ポイント不足 (>= ${analysis.windowSize})`
              : "";
            return [
              analysis.name,
              formatNumber(analysis.pointCount),
              formatNumber(analysis.events.length),
              firstEvent ? firstEvent.startTimestamp : "-",
              formatNumber(analysis.totalStuckSamples),
              formatTicks(analysis.totalStuckTicks),
              note || "-",
            ];
          });
        return { headers, rows };
      }

      function renderSummary(table) {
        if (!table.headers.length) {
          summaryContainer.innerHTML = "<p>概要を表示できません。</p>";
          return;
        }
        const headerHtml = table.headers
          .map((label) => `<th>${escapeHtml(label)}</th>`)
          .join("");
        const rowsHtml = table.rows
          .map((row) => {
            const tds = row
              .map((cell) => `<td>${escapeHtml(String(cell ?? ""))}</td>`)
              .join("");
            return `<tr>${tds}</tr>`;
          })
          .join("");
        summaryContainer.innerHTML = `
          <table>
            <thead>
              <tr>${headerHtml}</tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        `;
      }

      function buildEventsTableData(analyses) {
        const headers = [
          "トラック",
          "開始index",
          "終了index",
          "継続サンプル",
          "開始時刻",
          "終了時刻",
          "継続tick",
          "継続秒",
          "最大stdX",
          "最大stdZ",
        ];
        const rows = analyses
          .flatMap((analysis) =>
            analysis.events.map((event, index) => ({
              analysis,
              event,
              index: index + 1,
            }))
          )
          .map(({ analysis, event, index }) => [
            `${analysis.name} (#${index})`,
            formatNumber(event.startIndex),
            formatNumber(event.endIndexExclusive - 1),
            formatNumber(event.sampleCount),
            event.startTimestamp || "-",
            event.endTimestamp || "-",
            formatTicks(event.durationTicks),
            formatSeconds(event.durationTicks),
            formatStd(event.maxStdX),
            formatStd(event.maxStdZ),
          ]);
        return { headers, rows };
      }

      function renderEvents(table) {
        if (!table.headers.length) {
          eventsContainer.innerHTML = "<p>STUCKイベントはありません。</p>";
          return;
        }
        const headerHtml = table.headers
          .map((label) => `<th>${escapeHtml(label)}</th>`)
          .join("");
        const rowsHtml = table.rows
          .map((row) => {
            const tds = row
              .map((cell) => `<td>${escapeHtml(String(cell ?? ""))}</td>`)
              .join("");
            return `<tr>${tds}</tr>`;
          })
          .join("");
        eventsContainer.innerHTML = `
          <table>
            <thead>
              <tr>${headerHtml}</tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        `;
      }

      function analyzeTrack(track, options) {
        const { timeline } = track;
        const windowSize = options.windowSize;
        const threshold = options.stdThreshold;
        const pointCount = timeline.length;
        const insufficientPoints = pointCount < windowSize;
        const events = [];

        if (!timeline.length) {
          return buildResult();
        }

        if (insufficientPoints) {
          return buildResult();
        }

        const prefixX = buildPrefix(timeline, "x");
        const prefixX2 = buildPrefixSquared(timeline, "x");
        const prefixZ = buildPrefix(timeline, "z");
        const prefixZ2 = buildPrefixSquared(timeline, "z");

        let currentEvent = null;

        for (let endIndex = windowSize; endIndex <= pointCount; endIndex++) {
          const startIndex = endIndex - windowSize;
          const stdX = calculateStd(prefixX, prefixX2, startIndex, endIndex);
          const stdZ = calculateStd(prefixZ, prefixZ2, startIndex, endIndex);
          const windowStd = Math.max(stdX, stdZ);
          const isStuck =
            Number.isFinite(windowStd) && windowStd <= threshold + 1e-9;

          if (isStuck) {
            if (!currentEvent) {
              currentEvent = {
                startIndex,
                endIndexExclusive: endIndex,
                maxStdX: stdX,
                maxStdZ: stdZ,
              };
            } else {
              currentEvent.endIndexExclusive = endIndex;
              currentEvent.maxStdX = Math.max(currentEvent.maxStdX, stdX);
              currentEvent.maxStdZ = Math.max(currentEvent.maxStdZ, stdZ);
            }
          } else if (currentEvent) {
            finalizeEvent(currentEvent);
            currentEvent = null;
          }
        }

        if (currentEvent) {
          finalizeEvent(currentEvent);
        }

        return buildResult();

        function finalizeEvent(event) {
          const startEntry = timeline[event.startIndex] || null;
          const endEntry = timeline[event.endIndexExclusive - 1] || null;
          const startNumeric = startEntry
            ? startEntry.numericTimestamp
            : NaN;
          const endNumeric = endEntry ? endEntry.numericTimestamp : NaN;
          const durationTicks =
            Number.isFinite(startNumeric) && Number.isFinite(endNumeric)
              ? endNumeric - startNumeric
              : NaN;
          events.push({
            trackId: track.id,
            trackName: track.name,
            startIndex: event.startIndex,
            endIndexExclusive: event.endIndexExclusive,
            startTimestamp: startEntry
              ? startEntry.originalTimestamp
              : "-",
            endTimestamp: endEntry ? endEntry.originalTimestamp : "-",
            startNumeric,
            endNumeric,
            sampleCount: event.endIndexExclusive - event.startIndex,
            durationTicks,
            maxStdX: event.maxStdX,
            maxStdZ: event.maxStdZ,
          });
        }

        function buildResult() {
          const totalStuckSamples = events.reduce(
            (sum, event) => sum + event.sampleCount,
            0
          );
          const totalStuckTicks = events.reduce((sum, event) => {
            if (Number.isFinite(event.durationTicks)) {
              return sum + event.durationTicks;
            }
            return sum;
          }, 0);
          return {
            id: track.id,
            name: track.name,
            windowSize,
            threshold,
            pointCount,
            firstTimestamp: timeline[0]
              ? timeline[0].originalTimestamp
              : "-",
            lastTimestamp: timeline[pointCount - 1]
              ? timeline[pointCount - 1].originalTimestamp
              : "-",
            events,
            totalStuckSamples,
            totalStuckTicks,
            insufficientPoints,
          };
        }
      }

      function buildPrefix(timeline, axis) {
        const prefix = new Array(timeline.length + 1).fill(0);
        for (let i = 0; i < timeline.length; i++) {
          prefix[i + 1] = prefix[i] + timeline[i][axis];
        }
        return prefix;
      }

      function buildPrefixSquared(timeline, axis) {
        const prefix = new Array(timeline.length + 1).fill(0);
        for (let i = 0; i < timeline.length; i++) {
          const value = timeline[i][axis];
          prefix[i + 1] = prefix[i] + value * value;
        }
        return prefix;
      }

      function calculateStd(prefix, prefixSquared, startIndex, endIndex) {
        const count = endIndex - startIndex;
        if (count <= 0) {
          return NaN;
        }
        const sum = prefix[endIndex] - prefix[startIndex];
        const sumSq = prefixSquared[endIndex] - prefixSquared[startIndex];
        const mean = sum / count;
        const variance = sumSq / count - mean * mean;
        return Math.sqrt(Math.max(0, variance));
      }

      function formatNumber(value, fractionDigits = 0) {
        if (!Number.isFinite(value)) {
          return "-";
        }
        if (fractionDigits <= 0) {
          return String(Math.round(value));
        }
        const fixed = value.toFixed(fractionDigits);
        const numeric = Number(fixed);
        return Number.isInteger(numeric) ? String(numeric) : fixed;
      }

      function formatTicks(value) {
        if (!Number.isFinite(value)) {
          return "-";
        }
        return formatNumber(value, 2);
      }

      function formatSeconds(ticks) {
        if (!Number.isFinite(ticks)) {
          return "-";
        }
        return formatNumber(ticks / 20, 2);
      }

      function formatStd(value) {
        if (!Number.isFinite(value)) {
          return "-";
        }
        return formatNumber(value, 3);
      }

      function exportCsv(filename, table) {
        if (!table || !table.headers.length) {
          return;
        }
        const lines = [];
        lines.push(table.headers.map(escapeCsvValue).join(","));
        table.rows.forEach((row) => {
          lines.push(row.map(escapeCsvValue).join(","));
        });
        const csv = "\uFEFF" + lines.join("\r\n");
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        downloadBlob(blob, filename);
      }

      function escapeCsvValue(value) {
        if (value === null || value === undefined) {
          return "";
        }
        const stringValue = String(value);
        if (/[",\r\n]/.test(stringValue)) {
          return `"${stringValue.replace(/"/g, '""')}"`;
        }
        return stringValue;
      }

      function downloadBlob(blob, filename) {
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.href = url;
        link.download = filename;
        link.rel = "noopener";
        link.click();
        setTimeout(() => {
          URL.revokeObjectURL(url);
        }, 1000);
      }

      function escapeHtml(value) {
        if (typeof value !== "string") {
          return String(value ?? "");
        }
        return value
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function parseCsv(text) {
        const rows = [];
        let field = "";
        let row = [];
        let inQuotes = false;
        for (let i = 0; i < text.length; i += 1) {
          const char = text[i];
          if (inQuotes) {
            if (char === '"') {
              if (text[i + 1] === '"') {
                field += '"';
                i += 1;
              } else {
                inQuotes = false;
              }
            } else {
              field += char;
            }
            continue;
          }
          if (char === '"') {
            inQuotes = true;
            continue;
          }
          if (char === ",") {
            row.push(field.trim());
            field = "";
            continue;
          }
          if (char === "\n") {
            row.push(field.trim());
            if (row.some((value) => value.length > 0)) {
              rows.push(row);
            }
            row = [];
            field = "";
            continue;
          }
          if (char === "\r") {
            continue;
          }
          field += char;
        }
        row.push(field.trim());
        if (row.some((value) => value.length > 0)) {
          rows.push(row);
        }
        if (!rows.length) {
          return [];
        }

        let headerIndex = rows.findIndex((cols) =>
          cols.some((value) => value.length > 0)
        );
        if (headerIndex === -1) {
          return [];
        }
        const header = rows[headerIndex].map((value, index) =>
          index === 0 ? value.replace(/^\uFEFF/, "") : value
        );
        const dataRows = rows.slice(headerIndex + 1);
        return dataRows
          .filter((cols) => cols.some((value) => value.length > 0))
          .map((cols) => {
            const record = {};
            header.forEach((key, index) => {
              const columnKey = key || `column${index + 1}`;
              record[columnKey] = cols[index] ?? "";
            });
            return record;
          });
      }

      function extractTimeline(raw) {
        const rows = [];

        function pushEntry(entry, index, fallbackKey = null) {
          const coords = extractCoordinates(entry);
          if (!coords) {
            return;
          }
          const timestamp = readTimestamp(entry, index, fallbackKey);
          rows.push({
            originalTimestamp: timestamp.display,
            numericTimestamp: timestamp.numeric,
            x: coords.x,
            y: coords.y,
            z: coords.z,
          });
        }

        function processArray(array, baseKey = null) {
          array.forEach((entry, index) => {
            const fallbackKey = baseKey ? `${baseKey}[${index}]` : null;
            pushEntry(entry, index, fallbackKey);
          });
        }

        if (Array.isArray(raw)) {
          processArray(raw);
        } else if (raw && typeof raw === "object") {
          Object.entries(raw).forEach(([key, value], index) => {
            if (Array.isArray(value)) {
              processArray(value, key);
              return;
            }
            pushEntry(value, index, key);
          });
        }
        const allNumeric = rows.every((row) =>
          Number.isFinite(row.numericTimestamp)
        );
        if (allNumeric) {
          rows.sort((a, b) => a.numericTimestamp - b.numericTimestamp);
        }
        return rows;
      }

      function extractCoordinates(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }
        const direct = pickAxes(entry);
        if (direct) {
          return direct;
        }
        const coordinateWrappers = [
          "coordinate",
          "coordinates",
          "coords",
          "pos",
          "position",
          "location",
          "loc",
          "point",
          "座標",
        ];
        for (const key of coordinateWrappers) {
          if (entry[key] && typeof entry[key] === "object") {
            const nested = pickAxes(entry[key]);
            if (nested) {
              return nested;
            }
          }
        }
        return null;
      }

      function pickAxes(candidate) {
        if (!candidate || typeof candidate !== "object") {
          return null;
        }
        const x = readAxis(candidate, ["x", "X"]);
        const y = readAxis(candidate, ["y", "Y"]);
        const z = readAxis(candidate, ["z", "Z"]);
        if ([x, y, z].every((value) => Number.isFinite(value))) {
          return { x, y, z };
        }
        return null;
      }

      function readAxis(obj, keys) {
        for (const key of keys) {
          if (typeof obj[key] === "number") {
            return obj[key];
          }
          if (typeof obj[key] === "string") {
            const numeric = Number(obj[key]);
            if (Number.isFinite(numeric)) {
              return numeric;
            }
          }
        }
        return NaN;
      }

      function readTimestamp(entry, index, fallbackKey = null) {
        const candidates = [
          "timestamp",
          "time",
          "tick",
          "date",
          "step",
          "タイムスタンプ",
        ];
        for (const key of candidates) {
          if (entry && Object.prototype.hasOwnProperty.call(entry, key)) {
            const value = entry[key];
            if (Number.isFinite(Number(value))) {
              return { display: String(value), numeric: Number(value) };
            }
            return { display: String(value), numeric: index };
          }
        }
        if (fallbackKey !== null) {
          if (Number.isFinite(Number(fallbackKey))) {
            return { display: fallbackKey, numeric: Number(fallbackKey) };
          }
          return { display: fallbackKey, numeric: index };
        }
        return { display: `#${index}`, numeric: index };
      }
    </script>
  </body>
</html>
